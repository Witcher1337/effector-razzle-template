{"ast":null,"code":"var _effectorFileName = \"/src/server.tsx\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport express from \"express\";\nimport ReactDOM from \"react-dom/server\";\nimport mustache from \"mustache\";\nimport cookies from \"cookie-parser\";\nimport { createEvent, forward, fork, serialize, allSettled } from \"effector\";\nimport { Application } from \"./application\";\nimport { mustacheTemplate } from \"./application/template.mustache\";\nimport { StaticRouter } from 'react-router-dom/server';\nimport { CacheConfig } from './shared/configs/cache';\nimport { getStart } from 'shared/libs/page-routing';\nimport { routes } from 'pages/routes';\nimport { matchRoutes } from 'react-router-dom';\nimport { Provider } from 'effector-react/scope';\nexport const server = express();\n\nconst assets = require(process.env.RAZZLE_ASSETS_MANIFEST);\n\nconst lookupStartEvent = match => {\n  if (!match.route.element) return;\n  return getStart(match.route.element);\n};\n\nfunction routeWithEvent(event) {\n  return function (route) {\n    return lookupStartEvent(route) === event;\n  };\n}\n\nconst serverStarted = createEvent({\n  loc: {\n    file: _effectorFileName,\n    line: 36,\n    column: 22\n  },\n  name: \"serverStarted\",\n  sid: \"-4mlmyj\"\n});\nconst pathRequested = serverStarted.map(server => server.request);\nconst pathsMatched = pathRequested.map(({\n  protocol,\n  hostname,\n  url,\n  originalUrl\n}) => {\n  var _a;\n\n  const path = `${protocol}://${hostname}${originalUrl}`;\n  return {\n    routes: ((_a = matchRoutes(routes, url)) === null || _a === void 0 ? void 0 : _a.filter(lookupStartEvent)) || [],\n    query: Object.fromEntries(new URL(path).searchParams)\n  };\n});\n\nfor (const route of routes) {\n  const startPageEvent = getStart(route.element);\n  console.log(Boolean(startPageEvent), 'startPageEvent');\n  if (!startPageEvent) continue;\n  const matchedRoute = pathsMatched.filterMap(({\n    routes,\n    query\n  }) => {\n    const route = routes.find(routeWithEvent(startPageEvent));\n\n    if (route) {\n      return {\n        route,\n        query\n      };\n    }\n  });\n  forward({\n    and: {\n      from: matchedRoute.map(({\n        route,\n        query\n      }) => ({\n        path: route.pathname,\n        params: route.params,\n        query\n      })),\n      to: startPageEvent\n    },\n    or: {\n      loc: {\n        file: _effectorFileName,\n        line: 60,\n        column: 4\n      },\n      sid: \"4j2ee2\"\n    }\n  });\n}\n\nserver.disable(\"x-powered-by\").use(express.static(process.env.RAZZLE_PUBLIC_DIR)).use(cookies()).get(\"/*\", (request, response) => __awaiter(void 0, void 0, void 0, function* () {\n  const values = new Map();\n  const scope = fork({\n    values\n  });\n\n  try {\n    yield allSettled(serverStarted, {\n      scope,\n      params: {\n        request,\n        response\n      }\n    });\n  } catch (error) {\n    console.error(error);\n  }\n\n  const application = _jsx(StaticRouter, Object.assign({\n    location: request.url\n  }, {\n    children: _jsx(Provider, Object.assign({\n      value: scope\n    }, {\n      children: _jsx(Application, {})\n    }))\n  }));\n\n  const html = mustache.render(mustacheTemplate, {\n    markup: ReactDOM.renderToString(application),\n    initialState: JSON.stringify(serialize(scope)),\n    title: \"Title\",\n    assets: assets.client\n  });\n  response.cookie(\"entry-path\", request.path, {\n    maxAge: CacheConfig.time.unlimited\n  });\n  response.send(html);\n}));","map":{"version":3,"mappings":"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","names":["express","ReactDOM","mustache","cookies","createEvent","forward","fork","serialize","allSettled","Application","mustacheTemplate","StaticRouter","CacheConfig","getStart","routes","matchRoutes","Provider","server","assets","require","process","env","RAZZLE_ASSETS_MANIFEST","lookupStartEvent","match","route","element","routeWithEvent","event","serverStarted","pathRequested","map","request","pathsMatched","protocol","hostname","url","originalUrl","path","_a","filter","query","Object","fromEntries","URL","searchParams","startPageEvent","console","log","Boolean","matchedRoute","filterMap","find","from","pathname","params","to","disable","use","static","RAZZLE_PUBLIC_DIR","get","response","__awaiter","values","Map","scope","error","application","_jsx","location","children","value","html","render","markup","renderToString","initialState","JSON","stringify","title","client","cookie","maxAge","time","unlimited","send"],"sourceRoot":"","sources":["/Users/Root/Desktop/with-typescript-plugin/src/server.tsx"],"sourcesContent":["import express, {Request, Response} from \"express\";\nimport ReactDOM from \"react-dom/server\";\nimport mustache from \"mustache\";\nimport cookies from \"cookie-parser\";\nimport {createEvent, Event, forward, fork, serialize, allSettled} from \"effector\";\n\nimport {Application} from \"./application\";\nimport  {mustacheTemplate} from \"./application/template.mustache\";\nimport {StaticRouter} from 'react-router-dom/server';\nimport {CacheConfig} from './shared/configs/cache';\nimport {getStart, StartEvent} from 'shared/libs/page-routing';\nimport {routes} from 'pages/routes';\nimport {RouteMatch, matchRoutes} from 'react-router-dom';\nimport {Provider} from 'effector-react/scope';\n\nexport type ServerStarted = {\n  request: Request;\n  response: Response;\n};\n\nexport type ApplicationAssets = {\n  client: {\n    css?: string;\n    js?: string;\n  };\n};\n\nexport const server = express();\n\nconst assets: ApplicationAssets = require(process.env.RAZZLE_ASSETS_MANIFEST!);\n\nconst lookupStartEvent = (match: RouteMatch) => {\n  if (!match.route.element) return\n\n  return getStart(match.route.element);\n\n}\n\nfunction routeWithEvent(event: Event<StartEvent>) {\n  return function (route: RouteMatch) {\n    return lookupStartEvent(route) === event;\n  };\n}\n\nconst serverStarted = createEvent<ServerStarted>();\nconst pathRequested = serverStarted.map((server) => server.request);\n\nconst pathsMatched = pathRequested.map(({protocol, hostname, url, originalUrl}) => {\n  const path = `${protocol}://${hostname}${originalUrl}`;\n\n  return {\n    routes: matchRoutes(routes, url)?.filter(lookupStartEvent) || [],\n    query: Object.fromEntries(new URL(path).searchParams),\n  };\n});\n\nfor (const route of routes) {\n  const startPageEvent = getStart(route.element);\n\n  console.log(Boolean(startPageEvent), 'startPageEvent');\n  if (!startPageEvent) continue;\n\n  const matchedRoute = pathsMatched.filterMap(({routes, query}) => {\n    const route = routes.find(routeWithEvent(startPageEvent));\n\n    if (route) {\n      return {\n        route,\n        query,\n      };\n    }\n  });\n\n  forward({\n    from: matchedRoute.map(({route, query}) => ({\n      path: route.pathname,\n      params: route.params,\n      query,\n    })),\n    to: startPageEvent,\n  });\n}\n\n\nserver\n  .disable(\"x-powered-by\")\n  .use(express.static(process.env.RAZZLE_PUBLIC_DIR!))\n  .use(cookies())\n  .get(\"/*\", async (request, response) => {\n    const values = new Map();\n    const scope = fork({\n      values,\n    });\n\n    try {\n      await allSettled(serverStarted, {\n        scope,\n        params: {\n          request,\n          response,\n        },\n      });\n    } catch (error) {\n      console.error(error);\n    }\n\n    const application = (\n      <StaticRouter location={request.url}>\n        <Provider value={scope}>\n          <Application />\n        </Provider>\n      </StaticRouter>\n    );\n\n\n    const html = mustache.render(mustacheTemplate, {\n      markup: ReactDOM.renderToString(application),\n      initialState: JSON.stringify(serialize(scope)),\n      title: \"Title\",\n      assets: assets.client,\n    });\n\n    response.cookie(\"entry-path\", request.path, {\n      maxAge: CacheConfig.time.unlimited,\n    });\n\n    response.send(html);\n  });\n\n  "]},"metadata":{},"sourceType":"module"}